{"version":3,"sources":["src/cat-log-service.js","src/cat-http-appender.js"],"names":[],"mappings":"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","file":"cat-log4angular.min.js","sourcesContent":["'use strict';\n\n/*\n * EcmaScript5 compatible logging based on ideas from Diary.js\n * see https://docs.google.com/document/d/1gGUEODxxDjY7azF8InqtN1pRcLo3WhGb8BcoIihyI80/edit#heading=h.w7kphvm7blel\n *\n * More details:\n * https://github.com/angular/diary.js/blob/master/src/diary.js\n * http://log4javascript.org/\n *\n *\n * Appender interface:\n * {\n *  report(level, group, message [, memorySizes]) : function called by the logger, if the configured log level is met\n * }\n */\nangular\n    .module('cat.service.log', [])\n    .constant('ROOT_LOGGER_NAME', 'ROOT')\n    .constant('DEFAULT_LEVEL', 'info')\n    .constant('LOG_LEVEL_ORDER', {'debug': 1, 'info': 2, 'warn': 3, 'error': 4})\n    .constant('CONSOLE_APPENDER', {\n        report: function (level, group, message) {\n            if (typeof console === 'object') {\n                console[level](group + ' ' + message);\n            }\n        }\n    })\n    .provider('catLogService', ['ROOT_LOGGER_NAME', 'DEFAULT_LEVEL', 'LOG_LEVEL_ORDER',\n        function (ROOT_LOGGER_NAME, DEFAULT_LEVEL, LOG_LEVEL_ORDER) {\n            // available levels: log, debug, info, warn, error\n            var providerSelf = this;\n            var config = {};\n            config[ROOT_LOGGER_NAME] = DEFAULT_LEVEL;\n            var dumpMemorySizes = false;\n\n            var appenderList = [];\n\n            var configureLogLevel = function (group, level) {\n                if (group === ROOT_LOGGER_NAME && level === undefined) {\n                    throw new Error('Cannot undefine the log level of the root logger.');\n                }\n                config[group] = level;\n                return this;\n            };\n\n            this.configure = configureLogLevel;\n            this.appender = function (appender) {\n                appenderList.push(appender);\n                return this;\n            };\n            this.enableMemorySizes = function () {\n                dumpMemorySizes = true;\n                return this;\n            };\n            this.disableMemorySizes = function () {\n                dumpMemorySizes = false;\n                return this;\n            };\n\n            this.$get = function () {\n                var rootLogger = {\n                    parent: undefined,\n                    group: ROOT_LOGGER_NAME,\n                    resolveLevel: function () {\n                        return config[ROOT_LOGGER_NAME];\n                    },\n                    setLevel: function (newLevel) {\n                        configureLogLevel(this.group, newLevel);\n                    }\n                };\n                /*\n                 Resolves the log level for the current logger, by travelling up the hierarchy\n                 if no log level is defined for the current logger.\n                 This method could be memoized.\n                 */\n                var resolveLevel = function () {\n                    if (angular.isDefined(config[this.group])) {\n                        // log level is defined, use it\n                        return config[this.group];\n                    } else if (angular.isDefined(this.parent)) {\n                        return this.parent.resolveLevel();\n                    } else {\n                        throw new Error('Neither log level nor parent set for this logger: \"' + this.group + '\".');\n                    }\n                };\n                var loggify = function (logger) {\n                    angular.forEach(['debug', 'info', 'warn', 'error'], function (level) {\n                        var methodLvlNumber = LOG_LEVEL_ORDER[level];\n                        var log = function (message) {\n                            if (LOG_LEVEL_ORDER[logger.resolveLevel()] <= methodLvlNumber) {\n                                angular.forEach(appenderList, function (appender) {\n                                    var memorySizes;\n                                    if (dumpMemorySizes && window.performance && window.performance.memory) {\n                                        memorySizes = window.performance.memory;\n                                    }\n                                    appender.report(level, logger.group, message, memorySizes);\n                                });\n                            }\n                        };\n                        logger[level] = function (message, func) {\n                            if (typeof func === 'undefined') {\n                                log(message);\n                            } else {\n                                // performance measurement\n                                var start = new Date().getTime();\n                                log('BEFORE: ' + message);\n                                func();\n                                var elapsed = new Date().getTime() - start;\n                                log('AFTER: ' + message + ' took ' + elapsed + ' ms');\n                            }\n                        };\n                    });\n                };\n                loggify(rootLogger);\n                return {\n                    Logger: function (group, parent) {\n                        if (angular.isUndefined(group)) {\n                            return rootLogger;\n                        }\n                        if (angular.isUndefined(parent)) {\n                            // use root logger as default parent\n                            parent = rootLogger;\n                        }\n                        // possibility to memoize the logger object\n                        var logger = {\n                            parent: parent,\n                            group: group,\n                            resolveLevel: resolveLevel,\n                            setLevel: function (newLevel) {\n                                configureLogLevel(this.group, newLevel);\n                            }\n                        };\n                        loggify(logger);\n                        return logger;\n                    },\n                    appender: providerSelf.appender\n                };\n            };\n        }])\n    .config(function ($provide) {\n        $provide.decorator('$log', ['$delegate', 'catLogService', 'ROOT_LOGGER_NAME', function ($delegate, catLogService, ROOT_LOGGER_NAME) {\n            // instantiate  root logger\n            var rootLogger = catLogService.Logger();\n\n            angular.forEach(['debug', 'info', 'warn', 'error'], function (level) {\n                $delegate[level] = rootLogger[level];\n            });\n            $delegate.Logger = catLogService.Logger;\n            $delegate.setLevel = rootLogger.setLevel;\n            $delegate.group = ROOT_LOGGER_NAME;\n\n            return $delegate;\n        }]);\n    })\n;\n","'use strict';\n\n/*\n * HTTP Upload Appender for ngLogCustom module\n *\n * Uploads the logs that have a log level >= minLevel to postUrl in the specified interval.\n * No uploads happen if no suitable logs have been produced.\n */\nangular\n    .module('cat.service.log')\n    .constant('HTTP_LOGGER_NAME', 'catHttpLogAppender')\n    .provider('catHttpLogAppender', function () {\n        var intervalInSeconds = 10;\n        var postUrl;\n        var minLevel = 'info';\n        this.interval = function (_intervalInSeconds) {\n            intervalInSeconds = _intervalInSeconds;\n            return this;\n        };\n        this.postUrl = function (_postUrl) {\n            postUrl = _postUrl;\n            return this;\n        };\n        this.minUploadLevel = function (_minLevel) {\n            minLevel = _minLevel;\n            return this;\n        };\n        this.$get = ['$http', '$interval', '$log', 'HTTP_LOGGER_NAME', 'LOG_LEVEL_ORDER', function ($http, $interval, $log, HTTP_LOGGER_NAME, LOG_LEVEL_ORDER) {\n            var logger = $log.Logger(HTTP_LOGGER_NAME);\n            if (typeof postUrl === 'undefined') {\n                throw new Error('catHttpLogAppenderProvider requires definition of postUrl');\n            }\n            var logs = [];\n\n            var appender = {\n                report: function (level, group, message, memorySizes) {\n                    logs.push({\n                        level: level,\n                        group: group,\n                        message: message,\n                        memorySizes: memorySizes,\n                        timestamp: new Date().getTime()\n                    });\n                },\n                flush: function () {\n                    var minLevelOrder = LOG_LEVEL_ORDER[minLevel];\n                    var logsToSend = [];\n                    angular.forEach(logs, function (logEntry) {\n                        if (LOG_LEVEL_ORDER[logEntry.level] >= minLevelOrder) {\n                            logsToSend.push(logEntry);\n                        }\n                    });\n                    logs.length = 0;\n                    if (logsToSend.length > 0) {\n                        return $http.post(postUrl, logsToSend)\n                            .success(function () {\n                                logger.debug('Successfully uploaded logs.');\n                            })\n                            .error(function (data, status, headers, config, statusText) {\n                                logger.debug('Error uploading logs: ' + status + ' ' + statusText);\n                            });\n                    } else {\n                        logger.debug('No logs to upload - skipping upload request.');\n                    }\n                }\n            };\n            $interval(appender.flush, intervalInSeconds * 1000, 0, false);\n            return appender;\n        }];\n    })\n;"],"sourceRoot":"../src"}