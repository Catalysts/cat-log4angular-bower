{"version":3,"sources":["cat-log-service.js","cat-http-appender.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"cat-log4angular.js","sourcesContent":["'use strict';\n\n/*\n * EcmaScript5 compatible logging based on ideas from Diary.js\n * see https://docs.google.com/document/d/1gGUEODxxDjY7azF8InqtN1pRcLo3WhGb8BcoIihyI80/edit#heading=h.w7kphvm7blel\n *\n * More details:\n * https://github.com/angular/diary.js/blob/master/src/diary.js\n * http://log4javascript.org/\n *\n *\n * Appender interface:\n * {\n *  report(level, group, message [, memorySizes]) : function called by the logger, if the configured log level is met\n * }\n */\nangular\n    .module('cat.service.log', [])\n    .constant('ROOT_LOGGER_NAME', 'ROOT')\n    .constant('DEFAULT_LEVEL', 'info')\n    .constant('LOG_LEVEL_ORDER', {'debug': 1, 'info': 2, 'warn': 3, 'error': 4})\n    .constant('CONSOLE_APPENDER', {\n        report: function (level, group, message) {\n            if (typeof console === 'object') {\n                console[level](group + ' ' + message);\n            }\n        }\n    })\n    .provider('catLogService', ['ROOT_LOGGER_NAME', 'DEFAULT_LEVEL', 'LOG_LEVEL_ORDER',\n        function (ROOT_LOGGER_NAME, DEFAULT_LEVEL, LOG_LEVEL_ORDER) {\n            // available levels: log, debug, info, warn, error\n            var providerSelf = this;\n            var config = {};\n            config[ROOT_LOGGER_NAME] = DEFAULT_LEVEL;\n            var dumpMemorySizes = false;\n\n            var appenderList = [];\n\n            var configureLogLevel = function (group, level) {\n                if (group === ROOT_LOGGER_NAME && level === undefined) {\n                    throw new Error('Cannot undefine the log level of the root logger.');\n                }\n                config[group] = level;\n                return this;\n            };\n\n            this.configure = configureLogLevel;\n            this.appender = function (appender) {\n                appenderList.push(appender);\n                return this;\n            };\n            this.enableMemorySizes = function () {\n                dumpMemorySizes = true;\n                return this;\n            };\n            this.disableMemorySizes = function () {\n                dumpMemorySizes = false;\n                return this;\n            };\n\n            this.$get = function () {\n                var rootLogger = {\n                    parent: undefined,\n                    group: ROOT_LOGGER_NAME,\n                    resolveLevel: function () {\n                        return config[ROOT_LOGGER_NAME];\n                    },\n                    setLevel: function (newLevel) {\n                        configureLogLevel(this.group, newLevel);\n                    }\n                };\n                /*\n                 Resolves the log level for the current logger, by travelling up the hierarchy\n                 if no log level is defined for the current logger.\n                 This method could be memoized.\n                 */\n                var resolveLevel = function () {\n                    if (angular.isDefined(config[this.group])) {\n                        // log level is defined, use it\n                        return config[this.group];\n                    } else if (angular.isDefined(this.parent)) {\n                        return this.parent.resolveLevel();\n                    } else {\n                        throw new Error('Neither log level nor parent set for this logger: \"' + this.group + '\".');\n                    }\n                };\n                var loggify = function (logger) {\n                    angular.forEach(['debug', 'info', 'warn', 'error'], function (level) {\n                        var methodLvlNumber = LOG_LEVEL_ORDER[level];\n                        var log = function (message) {\n                            if (LOG_LEVEL_ORDER[logger.resolveLevel()] <= methodLvlNumber) {\n                                angular.forEach(appenderList, function (appender) {\n                                    var memorySizes;\n                                    if (dumpMemorySizes && window.performance && window.performance.memory) {\n                                        memorySizes = window.performance.memory;\n                                    }\n                                    appender.report(level, logger.group, message, memorySizes);\n                                });\n                            }\n                        };\n                        logger[level] = function (message, func) {\n                            if (typeof func === 'undefined') {\n                                log(message);\n                            } else {\n                                // performance measurement\n                                var start = new Date().getTime();\n                                log('BEFORE: ' + message);\n                                func();\n                                var elapsed = new Date().getTime() - start;\n                                log('AFTER: ' + message + ' took ' + elapsed + ' ms');\n                            }\n                        };\n                    });\n                };\n                loggify(rootLogger);\n                return {\n                    Logger: function (group, parent) {\n                        if (angular.isUndefined(group)) {\n                            return rootLogger;\n                        }\n                        if (angular.isUndefined(parent)) {\n                            // use root logger as default parent\n                            parent = rootLogger;\n                        }\n                        // possibility to memoize the logger object\n                        var logger = {\n                            parent: parent,\n                            group: group,\n                            resolveLevel: resolveLevel,\n                            setLevel: function (newLevel) {\n                                configureLogLevel(this.group, newLevel);\n                            }\n                        };\n                        loggify(logger);\n                        return logger;\n                    },\n                    appender: providerSelf.appender\n                };\n            };\n        }])\n    .config(function ($provide) {\n        $provide.decorator('$log', ['$delegate', 'catLogService', 'ROOT_LOGGER_NAME', function ($delegate, catLogService, ROOT_LOGGER_NAME) {\n            // instantiate  root logger\n            var rootLogger = catLogService.Logger();\n\n            angular.forEach(['debug', 'info', 'warn', 'error'], function (level) {\n                $delegate[level] = rootLogger[level];\n            });\n            $delegate.Logger = catLogService.Logger;\n            $delegate.setLevel = rootLogger.setLevel;\n            $delegate.group = ROOT_LOGGER_NAME;\n\n            return $delegate;\n        }]);\n    })\n;\n","'use strict';\n\n/*\n * HTTP Upload Appender for ngLogCustom module\n *\n * Uploads the logs that have a log level >= minLevel to postUrl in the specified interval.\n * No uploads happen if no suitable logs have been produced.\n */\nangular\n    .module('cat.service.log')\n    .constant('HTTP_LOGGER_NAME', 'catHttpLogAppender')\n    .provider('catHttpLogAppender', function () {\n        var intervalInSeconds = 10;\n        var postUrl;\n        var minLevel = 'info';\n        this.interval = function (_intervalInSeconds) {\n            intervalInSeconds = _intervalInSeconds;\n            return this;\n        };\n        this.postUrl = function (_postUrl) {\n            postUrl = _postUrl;\n            return this;\n        };\n        this.minUploadLevel = function (_minLevel) {\n            minLevel = _minLevel;\n            return this;\n        };\n        this.$get = ['$http', '$interval', '$log', 'HTTP_LOGGER_NAME', 'LOG_LEVEL_ORDER', function ($http, $interval, $log, HTTP_LOGGER_NAME, LOG_LEVEL_ORDER) {\n            var logger = $log.Logger(HTTP_LOGGER_NAME);\n            if (typeof postUrl === 'undefined') {\n                throw new Error('catHttpLogAppenderProvider requires definition of postUrl');\n            }\n            var logs = [];\n\n            var appender = {\n                report: function (level, group, message, memorySizes) {\n                    logs.push({\n                        level: level,\n                        group: group,\n                        message: typeof message === 'string' ? message : message.toString(),\n                        memorySizes: memorySizes,\n                        timestamp: new Date().getTime()\n                    });\n                },\n                flush: function () {\n                    var minLevelOrder = LOG_LEVEL_ORDER[minLevel];\n                    var logsToSend = [];\n                    angular.forEach(logs, function (logEntry) {\n                        if (LOG_LEVEL_ORDER[logEntry.level] >= minLevelOrder) {\n                            logsToSend.push(logEntry);\n                        }\n                    });\n                    logs.length = 0;\n                    if (logsToSend.length > 0) {\n                        return $http.post(postUrl, logsToSend)\n                            .success(function () {\n                                logger.debug('Successfully uploaded logs.');\n                            })\n                            .error(function (data, status, headers, config, statusText) {\n                                logger.debug('Error uploading logs: ' + status + ' ' + statusText);\n                            });\n                    } else {\n                        logger.debug('No logs to upload - skipping upload request.');\n                    }\n                }\n            };\n            $interval(appender.flush, intervalInSeconds * 1000, 0, false);\n            return appender;\n        }];\n    })\n;"],"sourceRoot":"src"}